#lang racket

;; Consider the problem of designing a signal-processing system to study the
;; homogeneous second-order linear differential equation

;; (d^2 y)/(dt^2) - a dy/dt - by = 0

;; The output stream, modeling y, is generated by a network that contains a
;; loop. This is because the value of d^2y/dt^2 depends upon the values of y
;; and dy/dt and both of these are determined by integrating d^2y/dt^2. The
;; diagram we would like to encode is shown in Figure 3.35. Write a procedure
;; solve-2nd that takes as arguments the constants a, b, and dt and the initial
;; values y0 and dy0 for y and dy/dt and generates the stream of successive
;; values of y.

(require "../../modules/streams.rkt")

(define (integral delayed-integrand initial-value dt)
  (define int
    (stream-cons
      initial-value
      (let ((integrand (force delayed-integrand)))
        (add-streams (scale-stream integrand dt) int))))
  int)

(define (solve-2nd a b dt y0 dy0)
  (define y (integral (delay dy) y0 dt))
  (define dy (integral (delay ddy) dy0 dt))
  (define ddy (add-streams (scale-stream dy a)
                           (scale-stream y b)))
  y)

;; r^2 + r - 2 = 0
;; roots: -2, 1
;; y(t) = c1 e^(r1 t) + c2 e^(r2 t)
;; y(t) = c1 e^(-2t) + c2 e^t
;; y(0) = c1 + c2 = 5
;; y'(t) = -2 c1 e^(-2t) + c2 e^t
;; y'(0) = -2 c1 + c2 = 3
;; c1 = 2/3
;; c2 = 13/3
;; y(t) = 2/3 e^(-2t) + 13/3 e^t

(define calc-y
  (let ((c1 2/3)
        (c2 13/3))
    (lambda (t)
      (+ (* c1 (exp (* -2 t)))
         (* c2 (exp t))))))
(for-each
  (lambda (t) (displayln (calc-y t)))
  (build-list 10 (lambda (x) (* x 0.01))))
;; 5
;; 5.030349839569231
;; 5.06139876621749
;; 5.0931460028547395
;; 5.125590919091438
;; 5.15873302965341
;; 5.19257199284133
;; 5.2271076090341415
;; 5.2623398192356285
;; 5.2982687036634255

(stream-display (stream-take (solve-2nd -1.0 2.0 0.01 5 3) 10))
;; 5
;; 5.03
;; 5.0593
;; 5.087887
;; 5.11574801
;; 5.1428700527
;; 5.169240166225
;; 5.19484540687471
;; 5.219672851897672
;; 5.2437096022894885

;; Pretty close
